#include "shellFunc.h"
#include "global.h"
#include <sys/wait.h>
#include "jobs.h"

#define MAX_TOKENS 256

char** tokens;
int status;


/**
 * Checks an array of chars for a |
 * @param Char array and length of the array
 * @return Integer regarding success; location of pipe  -1-no pipe
*/
int checkPipe(char input[], int length){
	int i = 0;
	while(i < length){
		if(input[i] == '|')
			return i;
		else
			i++;
	}
	return -1;
}


/**
 * Takes two char* each is one side of a pipeline, then them
 * @param char* leftside of pipeline and char* rightside of pipeline
*/
void processPipe(char* process1, char* process2){
	groupID = getpid(); //set the groupID to the pid of the current child process
	int pipeFD[2];	//create array to hold both file descriptor generated by pipe()

	if(pipe(pipeFD)==-1)	//make the two pipes
		perror("pipe(pipeFD) error");
	/*
	 *
	 * leftside of pipeline
	 *
	 */

	pid_t pid = fork();	//fork the process

	//in child process
	if(pid == 0){						

		//setpgid(getpid(),groupID);	//set the child'd group to be that of the it's parent

		if(close(pipeFD[0])==-1)	//close the read end of the pipe
			perror("process 1, close(pipeFD[0] error");
		
		if(pipeFD[1] != 1){ 	//if the pipeFD[1] is not already stdout
			if(dup2(pipeFD[1],1)==-1) //dup the pipeFD[1] to stdout
				perror("process 1 dup2(pipeFD[1],1) error");
		}
		processCommand(process1);	//run the first process
		if(close(pipeFD[1])==-1)	//close the write end of the pipe
			perror("process 1 close(pipeFD[1]) error");
		_exit(0);
	}
	//parent
	else{
		/*
		 *
		 * rightside of pipeline
		 *
		 */

		pid = fork(); //fork the process

		//in child
		if(pid == 0){

			//setpgid(getpid(),groupID);	//set the child'd group to be that of the it's parent

			if(close(pipeFD[1]==-1))	 //close the read end of the pipe
				perror("process 2, close(pipeFD[1] error");
			
			if(pipeFD[0] !=  0){		//if the pipeFD[0] is not already stdin
				if(dup2(pipeFD[0],0)==-1) //dup the pipeFD[0] to stdin
					perror("process 2 dup2(pipeFD[0],0) error");
			}
			
			processCommand(process2);	//run process 2
			
			if(close(pipeFD[0]==-1)) //close the write end of the pipe
				perror("process 2, close(pipeFD[0] error");
			
			_exit(0);
		}
		//parent
		else{
			wait(&status);
		}
	}
}
/**
 * Checks a char** for any redirection {<,>}
 * @param Char** to a list of tokens, int that represents which process
 * @return Integer regarding success; location of pipe  -1-no pipe
*/
void checkRed(char** tokens, int proc){
	int i = 0;
	while(tokens[i] != NULL){

		char* arg = tokens[i];
		int j = 0;
		while(arg[j] != '\0'){
			j++;
		}

		if(arg[j-1] == '>'){
			if(proc == 1){
				printf("Error: Overlapping Redirection\n");
			}
			else{
				printf("redirecting output\n");
				int new_out = open(tokens[i+1], O_WRONLY | O_CREAT , 0644);
				
				if(dup2(new_out, STDOUT_FILENO)==-1)
					perror("Pipe error");
					
				printf("output redirected to %s\n", tokens[i+1]);
				arg[j-1] = '\0';
			}
		}
		else if(arg[j-1] == '<'){
			if(proc == 2){
				printf("Error: Overlapping Redirection\n");
			}
			else{
				int new_in = open(tokens[i-1], O_RDONLY);
				if(dup2(new_in, STDIN_FILENO)==-1)
					perror("Pipe Error");
				printf("input redirected\n");
				arg[j-1] = '\0';
			}
		}

		i++;
	}
	return;


}
/**
 * takes a string and uses tokinizer to returns a list of tokens and their count
 * @param char* and by referance 'returns' a char** list of tokens
 * @return by referance 'returns' a char** list of tokens, int of the number of tokens
*/
int getTokens(char* input, char** tokens){
	//create tokenizer
	tokenizer = init_tokenizer(input);

	int i = 0;
	//while there are more tokens keep adding to the list
	while((tok = get_next_token(tokenizer)) != NULL){
		tokens[i++] = tok;
	}
	//clean up and free the tokenizer
	free_tokenizer(tokenizer);

	
	return i + 1; //return token count
}
/**
 * Check if the last char in the command is a &
 * @param Char* of the command to check
 * @return Integer regarding success; 1:there is an &  0:no &
*/
int checkBG(char* command){
	int j =0;

	//while we're not at the end of the char* command
	while(command[j] != '\0'){ 

		if (command[j] == '&'){		//background this process and remove the &
				command[j] = '\0';
			return 1; //return 1 for background proc
		}
		j++; 
	}
		//return 0 for forground process
		return 0;
}
/**
 * Checks an array of chars for a |
 * @param Char array and length of the array
 * @return Integer regarding success; location of pipe  -1-no pipe
*/
int processCommand(char* command){

	tokens = calloc(MAX_TOKENS, sizeof *tokens); //allocate memory for array for tokens

	status = checkBG(command);					//check for & for backgrounding a process

	getTokens(command, tokens);					//create array of tokens

    
	checkRed(tokens, 0);						//check for and handle redirection
 
	
	status = execvp(tokens[0], tokens);			//run the command
	
	//there was an error
	if(status==-1)
		perror("execvp error");
		
	
	free(tokens);	//clean up & free the tokens
	return(0);
}



