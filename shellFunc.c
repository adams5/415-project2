#include "shellFunc.h"
#include "global.h"
#include <sys/wait.h>
#include "jobs.h"

#define MAX_TOKENS 256

char** tokens;
int status;

int checkPipe(char input[], int length){
	for(int i=0; i < length; i++){
		if(input[i] == '|')
			return i;
	}
	return -1;
}

void processPipe(char* process1, char* process2){
	groupID = getpid();
	
	printf("Process pipe entered\n");
	int pipeFD[2];	//create array to hold both file descriptor generated by pipe()
	 //pid;		//create a process id
	//groupID = getpid(); //save the groupID as the parent's pid

	if(pipe(pipeFD)==-1)	//make the two pipes
		perror("pipe(pipeFD) error");
	/*
	 *
	 * PROCESS 1
	 *
	 */

	pid_t pid = fork();	//fork the process

	if(pid == 0){						//in child process

		//setpgid(getpid(),groupID);	//set the child'd group to be that of the it's parent

		if(close(pipeFD[0])==-1)	//close the read end of the pipe
			perror("process 1, close(pipeFD[0] error");
		
		if(pipeFD[1] != 1){ 	//if the pipeFD[1] is not already stdout
			if(dup2(pipeFD[1],1)==-1) //dup the pipeFD[1] to stdout
				perror("process 1 dup2(pipeFD[1],1) error");
		}
		//printf("processing process 1\n");
		processCommand(process1);	//run the first process
		//printf("done processing process 1\n");
		if(close(pipeFD[1])==-1)	//close the write end of the pipe
			perror("process 1 close(pipeFD[1]) error");
		_exit(0);
	}
	//parent
	else{
		/*if(waitpid(pid,&status,0)==-1)
			perror("process 1 waitpid(pid,&status,0) error");
		
		if(setpgid(getpid(),groupID)==-1) //set the parent's group id
			perror("process 1 setpgid(getpid(),groupID) error");*/
	

		/*
		 *
		 * PROCESS 2
		 *
		 */

		pid = fork(); //fork the process

		//in child
		if(pid == 0){

			//setpgid(getpid(),groupID);	//set the child'd group to be that of the it's parent

			if(close(pipeFD[1]==-1))	 //close the read end of the pipe
				perror("process 2, close(pipeFD[1] error");
			
			if(pipeFD[0] !=  0){		//if the pipeFD[0] is not already stdin
				if(dup2(pipeFD[0],0)==-1) //dup the pipeFD[0] to stdin
					perror("process 2 dup2(pipeFD[0],0) error");
			}
			
			//printf("processing process 2\n");
			processCommand(process2);	//run process 2
			//printf("done processing process 2\n");
			
			if(close(pipeFD[0]==-1)) //close the write end of the pipe
				perror("process 2, close(pipeFD[0] error");
			
			_exit(0);
		}
		//parent
		else{
			
			/*if(setpgid(getpid(),groupID)==-1) //set the parent's group id
				perror("process 2, setpgid(getpid(),groupID) error");
			if(waitpid(pid,&status,0)==-1)
				perror("process 2, waitpid(pid,&status,0) error");*/
				wait(&status);
		}
	}
}

void checkRed(char** tokens, int proc){
	int i = 0;
	while(tokens[i] != NULL){

		char* arg = tokens[i];
		int j = 0;
		while(arg[j] != '\0'){
			j++;
		}

		if(arg[j-1] == '>'){
			if(proc == 1){
				printf("Error: Overlapping Redirection\n");
			}
			else{
				printf("redirecting output\n");
				int new_out = open(tokens[i+1], O_WRONLY | O_CREAT , 0644);
				dup2(new_out, STDOUT_FILENO);
				printf("output redirected to %s\n", tokens[i+1]);
				arg[j-1] = '\0';
			}
		}
		else if(arg[j-1] == '<'){
			if(proc == 2){
				printf("Error: Overlapping Redirection\n");
			}
			else{
				int new_in = open(tokens[i-1], O_RDONLY);
				dup2(new_in, STDIN_FILENO);
				printf("input redirected\n");
				arg[j-1] = '\0';
			}
		}
	//else
		//printf("Parse Error:");
		i++;
	}
	return;


}

int getTokens(char* input, char** tokens){
	//create tokenizer
	tokenizer = init_tokenizer(input);

	int i = 0;
	while((tok = get_next_token(tokenizer)) != NULL){
		tokens[i++] = tok;
		printf("token is: %s\n", tokens[i-1]);
	}

	//int j;
	//for(j = 0; j < i; j++){
		//checkTok(tokens[j], j, tokens);
		//printf("Token at %i is %s\n", j, tokens[j]);
	//}

	free_tokenizer(tokenizer);

	return i +1;

}

int checkBG(char** command){
	int i =0;
	while(command[i] != NULL){ i++; }

	char* arg = command[i-1];
	int j = 0;
	while(arg[j] != '\0'){ j++; }

	if (arg[j-1] == '&'){		//background this process and remove the &

		////debugging
		//printf("printing original string\n");
		//int n = 0;
		//while(command[n] != NULL){printf("%s ", command[n]);n++;}
		//printf("\n");

		//background process
		printf("found &\n");
		if(j-1>0)
			arg[j-1] = '\0';
		else
			command[i-1] = NULL;
		
		////debugging		
		//printf("printing new string\n");
		//n=0;
		//while(command[n] != NULL){printf("%s", command[n]);n++;}
		//printf("\n");
		
		return 1;
	}
	else{
		//forground process
		return 0;
	}

}

int processCommand(char* command){

	tokens = calloc(MAX_TOKENS, sizeof *tokens);//allocate memory for array for tokens
	int numTokens = 0;							//value to hold how many tokens in input
	int status;

	numTokens = getTokens(command, tokens);	//create array of tokens
	
    printf("before checkbg, the value of tokens is:\n");
    int z = 0;
    while(z<numTokens){printf("%s ", tokens[z]);z++;}
    printf("\n");
    
	status = checkBG(tokens);				//check for & for backgrounding a process
	checkRed(tokens, 0);					//check for and handle redirection
    
    printf("after checkbg, the value of tokens is:\n");
    z = 0;
    while(z<numTokens){printf("%s ", tokens[z]);z++;}
    printf("\n");

    //if an & was found send the process to the background
	if(status == 1){
		printf("sending process to bg\n");
		sendToBG(getpid(), command);
	}
	//else send it to the foreground
	else{
		sendToFG(getpid());
	}
	
	//debugging
	for(int i = 0; i < numTokens; i++)
		printf("Token at %i is %s\n", i, tokens[i]);
	
	status = execvp(tokens[0], tokens);

	free(tokens);
	return(0);
}



